package com.lmbm.learning.programming;

import java.util.Scanner;

/**
 * Imprime en consola una letra ingresada por el usuario con uno's 
 * (sólo para matriz 8*8) obteniendo del valor hexadecimal (0x7E) de cada letra
 * su número binario compuesto de 8 bits. (00111100)
 *  v 0.0
 * 
 * @author Lux Ferre
 *
 */

public class Letters {

	private static Scanner lector;

	public static void main(String[] args) {

		lector = new Scanner(System.in);

		char[][] matriz = new char[8][8];

		System.out.println("Ingrese la palabra");
		String palabra = lector.next();

		for (int i = 0; i < palabra.length(); i++) {
			// Obtiene de la palabra ingresada cada letra
			String letter = String.valueOf(palabra.charAt(i));
			for (int j = 0; j < matriz.length; j++) {
				//Obtiene cada valor hex del vector para transformarlo a binario
				String p = Integer.toBinaryString(abecedario(letter)[j]);
				if (p.length() < 8) {
					/* Agrega los ceros que le falten al número a la izquierda
					 para completar los 8 bits en binario.*/
					p = String.format("%08d", Integer.parseInt(p));
				}
				// Llena la matriz
				for (int j2 = 0; j2 < matriz.length; j2++) {
					matriz[j][j2] = p.charAt(j2);
				}
			}
			
			System.out.println();
			for (int t = 0; t < matriz.length; t++) {
				for (int j = 0; j < matriz.length; j++) {
					System.out.print(" "+matriz[t][j]);
				}
				System.out.println();
			}
		}
	}

	public static byte[] abecedario(String letter) {

		switch (letter) {
		// abecedario
		case "A":
		case "a":
			byte A[] = { 0x3C, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42 }; // A
			return A;

		case "B":
		case "b":
			byte B[] = { 0x7C, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x7C }; // B
			return B;

		case "C":
		case "c":
			byte C[] = { 0x3E, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3E }; // C
			return C;

		case "D":
		case "d":
			byte D[] = { 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C }; // D
			return D;

		case "E":
		case "e":
			byte E[] = { 0x3E, 0x40, 0x40, 0x7C, 0x7C, 0x40, 0x40, 0x3E }; // E
			return E;

		case "F":
		case "f":
			byte F[] = { 0x7E, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40 }; // F
			return F;

		case "G":
		case "g":
			byte G[] = { 0x3E, 0x40, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x7A }; // G
			return G;

		case "H":
		case "h":
			byte H[] = { 0x42, 0x42, 0x42, 0x7E, 0x7E, 0x42, 0x42, 0x42 }; // H
			return H;

		case "I":
		case "i":
			byte I[] = { 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E }; // I
			return I;

		case "J":
		case "j":
			byte J[] = { 0x7E, 0x18, 0x18, 0x18, 0x18, 0x58, 0x58, 0x78 }; // J
			return J;

		case "K":
		case "k":
			byte K[] = { 0x44, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44, 0x42 }; // K
			return K;

		case "L":
		case "l":
			byte L[] = { 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E }; // L
			return L;

		case "M":
		case "m":
			byte M[] = { 0x66, 0x5A, 0x5A, 0x42, 0x42, 0x42, 0x42, 0x42 }; // M
			return M;

		case "N":
		case "n":
			byte N[] = { 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x42 }; // N
			return N;

		case "O":
		case "o":
			byte O[] = { 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7E }; // O
			return O;

		case "P":
		case "p":
			byte P[] = { 0x78, 0x44, 0x44, 0x44, 0x78, 0x40, 0x40, 0x40 }; // P
			return P;

		case "Q":
		case "q":
			byte Q[] = { 0x3C, 0x42, 0x42, 0x42, 0x4A, 0x44, 0x42, 0x3C }; // Q
			return Q;

		case "R":
		case "r":
			byte R[] = { 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x60, 0x50, 0x48 }; // R
			return R;

		case "S":
		case "s":
			byte S[] = { 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x02, 0x7C }; // S
			return S;

		case "T":
		case "t":
			byte T[] = { 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 }; // T
			return T;

		case "U":
		case "u":
			byte U[] = { 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18 }; // U
			return U;

		case "V":
		case "v":
			byte V[] = { 0x42, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x18 }; // V
			return V;

		case "W":
		case "w":
			byte W[] = { 0x42, 0x42, 0x42, 0x42, 0x42, 0x5A, 0x66, 0x42 }; // W
			return W;

		case "X":
		case "x":
			byte X[] = { 0x42, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x42 }; // X
			return X;

		case "Y":
		case "y":
			byte Y[] = { 0x42, 0x42, 0x24, 0x18, 0x10, 0x20, 0x40, 0x40 }; // Y
			return Y;

		case "Z":
		case "z":
			byte Z[] = { 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E }; // Z
			return Z;

		default:
			break;
		}

		return null;

		// // simbolos
		// byte num[] = { 0x24, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x24 }; // #
		// byte ast[] = { 0x5A, 0x5A, 0x3C, 0x7E, 0x7E, 0x3C, 0x5A, 0x5A }; // *
		// byte pre[] = { 0x3C, 0x02, 0x02, 0x1C, 0x18, 0x00, 0x18, 0x18 }; // ?
		// byte exc[] = { 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18 }; // !
		// byte dot[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60 }; // .
		// byte spa[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; //
		// ESPACIO
		// // "
		// // "
		//
		// // numeros
		// byte cero[] = { 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C }; //
		// CERO
		// byte uno[] = { 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E }; //
		// UNO
		// byte dos[] = { 0x78, 0x04, 0x04, 0x04, 0x3C, 0x40, 0x40, 0x3E }; //
		// DOS
		// byte tres[] = { 0x7C, 0x02, 0x02, 0x1C, 0x1C, 0x02, 0x02, 0x7C }; //
		// TRES
		// byte cuatro[] = { 0x0C, 0x14, 0x24, 0x44, 0x3E, 0x04, 0x04, 0x04 };
		// CUATRO
		// byte cinco[] = { 0x7E, 0x40, 0x40, 0x7C, 0x02, 0x02, 0x02, 0x7C }; //
		// CINCO
		// byte seis[] = { 0x3E, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x3C }; //
		// SEIS
		// byte siete[] = { 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40 }; //
		// SIETE
		// byte ocho[] = { 0x3C, 0x42, 0x42, 0x3C, 0x3C, 0x42, 0x42, 0x3C }; //
		// OCHO
		// byte nueve[] = { 0x3C, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C }; //
		// NUEVE

	}

}
